This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
test_model.py
test_serializer_create_concurrency.py
test_serializer_create.py
test_serializer_update.py
test_services.py
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="test_model.py">
from django.core.exceptions import ValidationError
from django.db import IntegrityError
from investments.models import Subscription
from tests.test_base_case import BaseAPITestCase


class SubscriptionModelTests(BaseAPITestCase):

    def test_create_subscription_success(self):
        """Test successful creation of a subscription."""
        sub = self.get_or_create_subscription(
            investor=self.investor1,
            project=self.project,
            amount=200.00,
            investment_share=2.00
        )
        self.assertEqual(sub.amount, 200.00)
        self.assertEqual(sub.investor, self.investor1)
        self.assertEqual(sub.project, self.project)

    def test_unique_investor_project_constraint(self):
        """Test that an investor cannot subscribe to the same project twice."""
        self.get_or_create_subscription(
            investor=self.investor1,
            project=self.project,
            amount=50.00
        )
        with self.assertRaises(IntegrityError) as ctx:
            self.get_or_create_subscription(
                investor=self.investor1,
                project=self.project,
                amount=70.00
            )
        self.assertIn("unique_investor_project", str(ctx.exception))

    def test_amount_min_value_validation(self):
        """Test that the minimum allowed investment amount is 0.01."""
        sub = Subscription(
            investor=self.investor1,
            project=self.project,
            amount=0.00
        )
        with self.assertRaises(ValidationError) as ctx:
            sub.full_clean()
        self.assertIn("Ensure this value is greater than or equal to 0.01", str(ctx.exception))

    def test_investor_cannot_invest_in_own_project(self):
        """Test that an investor cannot invest in their own project."""

        own_startup = self.get_or_create_startup(
            user=self.investor1.user,
            industry=self.industry,
            company_name="Investor Startup",
            location=self.startup_location
        )

        own_project = self.get_or_create_project(
            title="Project Beta",
            startup=own_startup
        )

        sub = Subscription(
            investor=self.investor1,
            project=own_project,
            amount=100.00
        )

        with self.assertRaises(ValidationError) as ctx:
            sub.full_clean()

        self.assertIn(
            "Investors cannot invest in their own startup's project.",
            str(ctx.exception)
        )

    def test_investment_share_value_range(self):
        """Test that investment_share must be between 0.00 and 100.00."""
        sub = Subscription(
            investor=self.investor1,
            project=self.project,
            amount=50.00,
            investment_share=150.00
        )
        with self.assertRaises(ValidationError) as ctx:
            sub.full_clean()
        self.assertIn("Ensure this value is less than or equal to 100", str(ctx.exception))
</file>

<file path="test_serializer_create_concurrency.py">
import threading
import time
from decimal import Decimal

from django.db import transaction, connections, close_old_connections
from django.db.models import F
from django.test import TransactionTestCase
from rest_framework import serializers

from common.enums import Stage
from investments.models import Subscription
from investments.serializers.subscription_create import SubscriptionCreateSerializer
from investments.services.subscriptions import get_total_subscribed
from investors.models import Investor
from projects.models import Project
from tests.elasticsearch.factories import UserFactory, IndustryFactory, LocationFactory, StartupFactory, ProjectFactory, \
    CategoryFactory


class SubscriptionSerializerConcurrencyTests(TransactionTestCase):
    reset_sequences = True

    @classmethod
    def tearDownClass(cls):
        super().tearDownClass()
        close_old_connections()
        for conn in connections.all():
            conn.close()

    def setUp(self):
        self.user1 = UserFactory.create()
        self.user2 = UserFactory.create()

        self.industry1 = IndustryFactory.create(name="Fintech")
        self.industry2 = IndustryFactory.create(name="E-commerce")
        self.location1 = LocationFactory.create(country="US")
        self.location2 = LocationFactory.create(country="DE")

        self.startup1 = StartupFactory.create(
            user=self.user1,
            industry=self.industry1,
            location=self.location1,
            company_name="Fintech Solutions",
            stage=Stage.IDEA,
        )
        self.investor1 = Investor.objects.create(
            user=self.user1,
            industry=self.industry1,
            company_name="Investor One",
            location=self.location1,
            email="investor1great@example.com",
            founded_year=2000,
            stage=Stage.MVP,
            fund_size=Decimal("1000000.00")
        )

        self.investor2 = Investor.objects.create(
            user=self.user2,
            industry=self.industry2,
            company_name="Investor Two",
            location=self.location2,
            email="investor2great@example.com",
            founded_year=2005,
            stage=Stage.MVP,
            fund_size=Decimal("2000000.00")
        )

        self.user3 = UserFactory.create()
        self.investor3 = Investor.objects.create(
            user=self.user3,
            industry=self.industry1,
            company_name="Investor Three",
            location=self.location1,
            email="investor3@example.com",
            founded_year=2010
        )

        self.category1 = CategoryFactory.create(name="Tech")

        self.project1 = ProjectFactory.create(
            startup=self.startup1,
            category=self.category1,
            title="First Test Project",
            funding_goal=Decimal("1000.00")
        )

    def get_subscription_data(self, investor, project, amount):
        return {
            "investor": investor.pk,
            "project": project.pk,
            "amount": amount
        }

    def test_concurrent_subscriptions(self):
        amount1 = Decimal("600.00")
        amount2 = Decimal("500.00")

        errors = []
        
        def subscribe(user, amount, delay=0):
            close_old_connections()
            time.sleep(delay)
            
            request_mock = type('Request', (), {'user': user})
            context = {'request': request_mock}

            data = self.get_subscription_data(user.investor, self.project1, amount)
            serializer = SubscriptionCreateSerializer(data=data, context=context)
            
            try:
                serializer.is_valid(raise_exception=True)
                
                with transaction.atomic():
                    subscription = serializer.save()
                    Project.objects.filter(pk=subscription.project_id).update(
                        current_funding=F('current_funding') + subscription.amount
                    )
            except serializers.ValidationError as e:
                errors.append(e.detail)
            except Exception as e:
                errors.append(str(e))


        t1 = threading.Thread(target=subscribe, args=(self.user2, amount1, 0))
        t2 = threading.Thread(target=subscribe, args=(self.user3, amount2, 0.05))

        t1.start()
        t2.start()
        t1.join()
        t2.join()

        for conn in connections.all():
            conn.close()

        total = get_total_subscribed(project=self.project1)
        self.assertLessEqual(total, self.project1.funding_goal)

        error_messages = [str(err).lower() for err in errors]

        self.assertTrue(
            any("exceeds the remaining funding" in msg for msg in error_messages),
            f"Expected funding goal exceeded error, got: {error_messages}"
        )
</file>

<file path="test_serializer_create.py">
from decimal import Decimal, ROUND_DOWN
from rest_framework.test import APIRequestFactory
from common.enums import Stage
from investments.serializers.subscription_create import SubscriptionCreateSerializer
from investments.services.investment_share_service import recalculate_investment_shares, calculate_investment_share
from tests.test_base_case import BaseAPITestCase


class SubscriptionSerializerValidDataTests(BaseAPITestCase):
    def test_subscription_serializer_valid_data(self):
        data = self.get_subscription_data(self.investor1, self.project, 250.00)
        
        factory = APIRequestFactory()
        request = factory.get('/')
        request.user = self.investor1.user
        
        serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
        self.assertTrue(serializer.is_valid(), f"Serializer validation failed: {serializer.errors}")

    def test_valid_subscription_creation(self):
        data = self.get_subscription_data(self.investor1, self.project, Decimal("250.00"))

        factory = APIRequestFactory()
        request = factory.get('/')
        request.user = self.investor1.user

        serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
        self.assertTrue(serializer.is_valid(), f"Serializer validation failed: {serializer.errors}")

        subscription = serializer.save()

        recalculate_investment_shares(self.project)
        subscription.refresh_from_db()

        expected_share = calculate_investment_share(subscription.amount, self.project.funding_goal)

        self.assertAlmostEqual(float(subscription.amount), 250.00, places=2)
        self.assertAlmostEqual(float(subscription.investment_share), float(expected_share), places=2)

    def test_rounding_of_investment_share(self):
        data = self.get_subscription_data(self.investor1, self.project, 333.33)

        factory = APIRequestFactory()
        request = factory.get('/')
        request.user = self.investor1.user

        serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
        self.assertTrue(serializer.is_valid(), serializer.errors)
        subscription = serializer.save()

        expected_share = (Decimal("333.33") / self.project.funding_goal * 100).quantize(Decimal("0.01"),
                                                                                        rounding=ROUND_DOWN)
        self.assertEqual(subscription.investment_share, expected_share)

    def test_minimum_amount_boundary(self):
        data = self.get_subscription_data(self.investor1, self.project, 0.01)

        factory = APIRequestFactory()
        request = factory.get('/')
        request.user = self.investor1.user

        serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
        self.assertTrue(serializer.is_valid(), serializer.errors)
        subscription = serializer.save()
        expected_share = (Decimal("0.01") / self.project.funding_goal * 100).quantize(Decimal("0.01"))
        self.assertEqual(subscription.investment_share, expected_share)

    def test_cumulative_rounding_errors(self):
        self.project.funding_goal = Decimal("100.00")
        self.project.save()

        increments = [Decimal("33.33"), Decimal("33.33"), Decimal("33.34")]
        subscriptions = []
        factory = APIRequestFactory()

        for i, amount in enumerate(increments, start=1):
            investor = getattr(self, f'investor{i}', None)
            if not investor:
                user = self.get_or_create_user(f"user{i}@example.com", f"Investor{i}", "Test")
                investor = self.get_or_create_investor(
                    user=user,
                    company_name=f"Investor {i}",
                    fund_size="1000000.00",
                    stage=Stage.SCALE
                )
                setattr(self, f'investor{i}', investor)

            data = self.get_subscription_data(investor, self.project, amount)
            
            request = factory.get('/')
            request.user = investor.user

            serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
            self.assertTrue(serializer.is_valid(), serializer.errors)
            subscription = serializer.save()
            subscriptions.append(subscription)

        recalculate_investment_shares(self.project)

        total_share = Decimal("0.00")
        for sub in subscriptions:
            sub.refresh_from_db()
            total_share += sub.investment_share

        self.assertLessEqual(total_share, Decimal("100.00"))
        self.assertGreaterEqual(total_share, Decimal("99.99"))
class SubscriptionSerializerAmountValidationTests(BaseAPITestCase):
    def test_missing_amount_field(self):
        data = self.get_subscription_data(self.investor1, self.project, 250.00)
        data.pop("amount")

        factory = APIRequestFactory()
        request = factory.get('/')
        request.user = self.investor1.user

        serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
        self.assertFalse(serializer.is_valid())
        self.assertIn("amount", serializer.errors)
        self.assertTrue(
            any("required" in str(msg).lower() for msg in serializer.errors["amount"]),
            f"Expected 'required' error message for missing amount, got: {serializer.errors['amount']}"
        )

    def test_negative_amount_is_rejected(self):
        data = self.get_subscription_data(self.investor1, self.project, -100.00)

        factory = APIRequestFactory()
        request = factory.get('/')
        request.user = self.investor1.user

        serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
        self.assertFalse(serializer.is_valid())
        self.assertIn("amount", serializer.errors)

        error_messages = serializer.errors["amount"]
        self.assertTrue(
            any("greater than or equal to" in str(msg).lower() for msg in error_messages),
            f"Expected 'amount' error message about positive value, got: {error_messages}"
        )

    def test_zero_amount_is_rejected(self):
        data = self.get_subscription_data(self.investor1, self.project, 0.00)
        
        factory = APIRequestFactory()
        request = factory.get('/')
        request.user = self.investor1.user

        serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
        self.assertFalse(serializer.is_valid())
        self.assertIn("amount", serializer.errors)

        error_messages = serializer.errors["amount"]
        self.assertTrue(
            any("greater than or equal to" in str(msg).lower() for msg in error_messages),
            f"Expected error message about amount being greater than 0, got: {error_messages}"
        )


#--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
class SubscriptionSerializerInvestmentConstraintsTests(BaseAPITestCase):
    def test_self_investment_rejected(self):
        self.project.startup.user = self.investor1.user
        self.project.startup.save()
        data = self.get_subscription_data(self.investor1, self.project, Decimal("100.00"))
        
        factory = APIRequestFactory()
        request = factory.get('/')
        request.user = self.investor1.user
        
        serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
        self.assertFalse(serializer.is_valid())
        self.assertIn("non_field_errors", serializer.errors)
        error_messages = serializer.errors["non_field_errors"]
        self.assertTrue(
            any("cannot invest in their own" in str(msg).lower() for msg in error_messages),
            f"Expected self-investment error, got: {error_messages}"
        )

    def test_exceeds_funding_goal(self):
        amount1 = (self.project.funding_goal * Decimal("0.9")).quantize(Decimal("0.01"), rounding=ROUND_DOWN)
        amount2 = (self.project.funding_goal * Decimal("0.2")).quantize(Decimal("0.01"), rounding=ROUND_DOWN)

        self.get_or_create_subscription(
            investor=self.investor1,
            project=self.project,
            amount=amount1,
            investment_share=Decimal("90.00")
        )

        data = self.get_subscription_data(
            self.investor2,
            self.project,
            amount2
        )

        factory = APIRequestFactory()
        request = factory.get('/')
        request.user = self.investor2.user
        
        serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
        self.assertFalse(serializer.is_valid())
        self.assertIn("amount", serializer.errors)
        error_messages = serializer.errors["amount"]
        self.assertTrue(
            any("exceeds funding goal" in str(msg).lower() for msg in error_messages),
            f"Expected 'exceeds funding goal' error message, got: {error_messages}"
        )

    def test_sequential_subscriptions_exceeding_funding_goal(self):
        amount1 = (self.project.funding_goal * Decimal("0.6")).quantize(Decimal("0.01"), rounding=ROUND_DOWN)
        first_data = self.get_subscription_data(self.investor1, self.project, amount1)

        amount2 = (self.project.funding_goal * Decimal("0.5")).quantize(Decimal("0.01"), rounding=ROUND_DOWN)
        second_data = self.get_subscription_data(self.investor2, self.project, amount2)
        
        factory = APIRequestFactory()
        request1 = factory.get('/')
        request1.user = self.investor1.user

        serializer1 = SubscriptionCreateSerializer(data=first_data, context={'request': request1})
        self.assertTrue(serializer1.is_valid(), serializer1.errors)
        serializer1.save()
        
        request2 = factory.get('/')
        request2.user = self.investor2.user
        
        serializer2 = SubscriptionCreateSerializer(data=second_data, context={'request': request2})
        self.assertFalse(serializer2.is_valid())
        self.assertIn("amount", serializer2.errors)
        error_messages = serializer2.errors["amount"]
        self.assertTrue(
            any("exceeds funding goal" in str(msg).lower() for msg in error_messages),
            f"Expected 'exceeds funding goal' error message, got: {error_messages}"
        )

    def test_fully_funded_project_no_more_subscriptions(self):
        self.get_or_create_subscription(
            investor=self.investor1,
            project=self.project,
            amount=self.project.funding_goal,
            investment_share=Decimal("100.00")
        )

        data = self.get_subscription_data(self.investor2, self.project, Decimal("1.00"))
        
        factory = APIRequestFactory()
        request = factory.get('/')
        request.user = self.investor2.user
        
        serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
        self.assertFalse(serializer.is_valid())
        self.assertTrue(
            "amount" in serializer.errors or "project" in serializer.errors,
            f"Expected validation error for fully funded project, got: {serializer.errors}"
        )
        error_messages = serializer.errors.get("amount", []) + serializer.errors.get("project", [])
        self.assertTrue(
            any("exceeds funding goal" in str(msg).lower() or "fully funded" in str(msg).lower()
                for msg in error_messages),
            f"Expected 'exceeds funding goal' error message, got: {error_messages}"
        )

    def test_total_investment_share_cannot_exceed_funding_goal(self):
        self.get_or_create_subscription(
            investor=self.investor1,
            project=self.project,
            amount=Decimal("600000.00")
        )
        self.get_or_create_subscription(
            investor=self.investor2,
            project=self.project,
            amount=Decimal("300000.00")
        )

        user3 = self.get_or_create_user("inv3@example.com", "Investor", "Three")
        investor3 = self.get_or_create_investor(
            user=user3,
            company_name="Investor Three",
            fund_size=Decimal("5000000.00"),
            stage=Stage.LAUNCH
        )

        data = self.get_subscription_data(investor3, self.project, Decimal("200000.00"))

        factory = APIRequestFactory()
        request = factory.get('/')
        request.user = investor3.user

        serializer = SubscriptionCreateSerializer(data=data, context={'request': request})
        self.assertFalse(serializer.is_valid())
        self.assertIn("amount", serializer.errors)
        error_messages = serializer.errors["amount"]
        self.assertTrue(
            any("exceeds funding goal" in str(msg).lower() for msg in error_messages),
            f"Expected 'exceeds funding goal' error message, got: {error_messages}"
        )
</file>

<file path="test_serializer_update.py">
from decimal import Decimal
from rest_framework import serializers
from investments.serializers.subscription_update import SubscriptionUpdateSerializer
from tests.test_base_case import BaseAPITestCase

class SubscriptionSerializerUpdateTests(BaseAPITestCase):
    """
    Tests for updating existing Subscription instances through the serializer.
    Covers:
        - Successful amount updates and share recalculation
        - No change when amount remains the same
        - Partial updates without amount field
        - Restrictions on changing investor or project during update
    """

    def test_update_subscription_amount_successfully(self):
        """Allow updating subscription amount and recalculate share."""
        subscription = self.get_or_create_subscription(
            investor=self.investor1,
            project=self.project,
            amount=Decimal("200.00"),
            investment_share=Decimal("0.02")
        )
        data = {"amount": Decimal("500.00")}

        serializer = SubscriptionUpdateSerializer(subscription, data=data, partial=True)
        self.assertTrue(serializer.is_valid(), serializer.errors)
        updated = serializer.save()

        self.assertEqual(updated.amount, Decimal("500.00"))
        self.assertAlmostEqual(updated.investment_share * 100, Decimal("5.00"))
        self.assertEqual(updated.investor, subscription.investor)
        self.assertEqual(updated.project, subscription.project)

    def test_update_subscription_amount_unchanged(self):
        """Updating with the same amount keeps investment share unchanged."""
        subscription = self.get_or_create_subscription(
            investor=self.investor1,
            project=self.project,
            amount=Decimal("200.00"),
            investment_share=Decimal("0.02")
        )
        data = {"amount": Decimal("200.00")}

        serializer = SubscriptionUpdateSerializer(subscription, data=data, partial=True)
        self.assertTrue(serializer.is_valid(), serializer.errors)
        updated = serializer.save()

        self.assertEqual(updated.amount, Decimal("200.00"))
        self.assertEqual(updated.investment_share * 100, Decimal("2.00"))

    def test_update_subscription_without_amount_field(self):
        """Partial update without amount leaves subscription unchanged."""
        subscription = self.get_or_create_subscription(
            investor=self.investor1,
            project=self.project,
            amount=Decimal("200.00"),
            investment_share=Decimal("0.02")
        )
        data = {}

        serializer = SubscriptionUpdateSerializer(subscription, data=data, partial=True)
        self.assertTrue(serializer.is_valid(), serializer.errors)
        updated = serializer.save()

        self.assertEqual(updated.amount, Decimal("200.00"))
        self.assertEqual(updated.investment_share * 100, Decimal("2.00"))

    def test_cannot_change_investor_on_update(self):
        """Prohibit changing investor on subscription update."""
        subscription = self.get_or_create_subscription(
            investor=self.investor1,
            project=self.project,
            amount=Decimal("200.00"),
            investment_share=Decimal("0.02")
        )
        data = {"investor": self.investor2.id, "amount": Decimal("100.00")}

        serializer = SubscriptionUpdateSerializer(subscription, data=data, partial=True)
        with self.assertRaises(serializers.ValidationError) as context:
            serializer.is_valid(raise_exception=True)

        self.assertIn("investor", context.exception.detail)

    def test_cannot_change_project_on_update(self):
        """Prohibit changing project on subscription update."""
        subscription = self.get_or_create_subscription(
            investor=self.investor1,
            project=self.project,
            amount=Decimal("200.00"),
            investment_share=Decimal("0.02")
        )
        new_project = self.get_or_create_project(
            title="Other Project",
            funding_goal=Decimal("20000.00")
        )
        data = {"project": new_project.id, "amount": Decimal("100.00")}

        serializer = SubscriptionUpdateSerializer(subscription, data=data, partial=True)
        with self.assertRaises(serializers.ValidationError) as context:
            serializer.is_valid(raise_exception=True)

        self.assertIn("project", context.exception.detail)
</file>

<file path="test_services.py">
from decimal import Decimal
from django.db import models
from django.test.utils import override_settings
from investments.models import Subscription
from investments.services.investment_share_service import recalculate_investment_shares, calculate_investment_share
from tests.test_base_case import BaseAPITestCase


@override_settings(CELERY_TASK_ALWAYS_EAGER=True)
class InvestmentShareServiceTest(BaseAPITestCase):
    """
    Test case for verifying the correct calculation of investment shares
    for subscriptions related to a project.
    """

    def test_recalculate_shares(self):
        """
        Subscriptions with amounts 100 and 300 should have shares 1.00 and 3.00,
        and total shares should be 4.00.
        """
        s1 = self.get_or_create_subscription(self.investor1, self.project, 100, 0.00)
        s2 = self.get_or_create_subscription(self.investor2, self.project, 300, 0.00)

        recalculate_investment_shares(self.project)

        s1.refresh_from_db()
        s2.refresh_from_db()

        self.assertEqual(s1.investment_share * 100, 1.00)
        self.assertEqual(s2.investment_share * 100, 3.00)

        total_share = Subscription.objects.filter(project=self.project).aggregate(
            total=models.Sum('investment_share')
        )['total']
        self.assertEqual(total_share * 100, Decimal('4.00'))

    def test_no_subscriptions(self):
        """
        Recalculation on a project with no subscriptions should not raise errors.
        """
        try:
            recalculate_investment_shares(self.project)
        except Exception as e:
            self.fail(f"Recalculation failed with no subscriptions: {e}")

    def test_zero_total_amount(self):
        """
        If all amounts are zero, all investment shares should be 0.00.
        """
        s1 = self.get_or_create_subscription(self.investor1, self.project, 0.00, 0.00)
        s2 = self.get_or_create_subscription(self.investor2, self.project, 0.00, 0.00)

        recalculate_investment_shares(self.project)

        s1.refresh_from_db()
        s2.refresh_from_db()

        self.assertEqual(s1.investment_share, 0.00)
        self.assertEqual(s2.investment_share, 0.00)

    def test_single_subscription_gets_100_percent(self):
        """
        A single subscription should get 100% investment share.
        """
        s1 = self.get_or_create_subscription(self.investor1, self.project, 10000.00, 0.00)

        recalculate_investment_shares(self.project)

        s1.refresh_from_db()
        self.assertEqual(s1.investment_share * 100, 100.0)

    def test_investment_share_precision(self):
        """
        Shares should be calculated as a percentage of funding_goal
        and rounded to 2 decimal places.
        """
        s1 = self.get_or_create_subscription(self.investor1, self.project, Decimal("3333.33"), Decimal("0.00"))
        s2 = self.get_or_create_subscription(self.investor2, self.project, Decimal("6666.67"), Decimal("0.00"))

        recalculate_investment_shares(self.project)

        s1.refresh_from_db()
        s2.refresh_from_db()

        expected_s1 = calculate_investment_share(s1.amount, self.project.funding_goal)
        expected_s2 = calculate_investment_share(s2.amount, self.project.funding_goal)

        self.assertEqual(s1.investment_share, expected_s1)
        self.assertEqual(s2.investment_share, expected_s2)
</file>

</files>
